<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>lgraph (light-Graph): lgraph::utils::svector&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">lgraph (light-Graph)
   &#160;<span id="projectnumber">2018/08/21</span>
   </div>
   <div id="projectbrief">A light-weight graph library focused on complex and social networks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelgraph.html">lgraph</a></li><li class="navelem"><a class="el" href="namespacelgraph_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="classlgraph_1_1utils_1_1svector.html">svector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlgraph_1_1utils_1_1svector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lgraph::utils::svector&lt; T, Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shortened vector.  
 <a href="classlgraph_1_1utils_1_1svector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="svector_8hpp_source.html">svector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a518288794e754e27d2e2274ced4485a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a518288794e754e27d2e2274ced4485a6"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a518288794e754e27d2e2274ced4485a6">iterator</a></td></tr>
<tr class="memdesc:a518288794e754e27d2e2274ced4485a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the iterator of svector class. <br/></td></tr>
<tr class="separator:a518288794e754e27d2e2274ced4485a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50774ce617a742e76f3fb8cc0a7a9445"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50774ce617a742e76f3fb8cc0a7a9445"></a>
typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a50774ce617a742e76f3fb8cc0a7a9445">const_iterator</a></td></tr>
<tr class="memdesc:a50774ce617a742e76f3fb8cc0a7a9445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the const iterator of svector class. <br/></td></tr>
<tr class="separator:a50774ce617a742e76f3fb8cc0a7a9445"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae2587ed7933a70b8367e178dd61f90f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2587ed7933a70b8367e178dd61f90f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#ae2587ed7933a70b8367e178dd61f90f9">svector</a> ()</td></tr>
<tr class="memdesc:ae2587ed7933a70b8367e178dd61f90f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br/></td></tr>
<tr class="separator:ae2587ed7933a70b8367e178dd61f90f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae71cfdb8e4d66c25a255b4a6bc7ad1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae71cfdb8e4d66c25a255b4a6bc7ad1c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#aae71cfdb8e4d66c25a255b4a6bc7ad1c">svector</a> (size_t n)</td></tr>
<tr class="memdesc:aae71cfdb8e4d66c25a255b4a6bc7ad1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a shortened vector that holds <em>n</em> elements. <br/></td></tr>
<tr class="separator:aae71cfdb8e4d66c25a255b4a6bc7ad1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350de4ad59381c976905881480b0ed05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a350de4ad59381c976905881480b0ed05"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a350de4ad59381c976905881480b0ed05">svector</a> (size_t n, const T &amp;v)</td></tr>
<tr class="memdesc:a350de4ad59381c976905881480b0ed05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a shortened vector that holds <em>n</em> elements, all of them being <em>v</em>. <br/></td></tr>
<tr class="separator:a350de4ad59381c976905881480b0ed05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32558a0ffa1a78f192d4294e37922cbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32558a0ffa1a78f192d4294e37922cbe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a32558a0ffa1a78f192d4294e37922cbe">~svector</a> ()</td></tr>
<tr class="memdesc:a32558a0ffa1a78f192d4294e37922cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a32558a0ffa1a78f192d4294e37922cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8b316c538de8368b1efdbf7764ac91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a518288794e754e27d2e2274ced4485a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#aeb8b316c538de8368b1efdbf7764ac91">begin</a> ()</td></tr>
<tr class="memdesc:aeb8b316c538de8368b1efdbf7764ac91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator at the beginning of the container.  <a href="#aeb8b316c538de8368b1efdbf7764ac91">More...</a><br/></td></tr>
<tr class="separator:aeb8b316c538de8368b1efdbf7764ac91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7345683988f337e5015850357ae08714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a50774ce617a742e76f3fb8cc0a7a9445">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a7345683988f337e5015850357ae08714">begin</a> () const </td></tr>
<tr class="memdesc:a7345683988f337e5015850357ae08714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator at the beginning of the container.  <a href="#a7345683988f337e5015850357ae08714">More...</a><br/></td></tr>
<tr class="separator:a7345683988f337e5015850357ae08714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bc452bc6022b65a0399de60b600565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a518288794e754e27d2e2274ced4485a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a07bc452bc6022b65a0399de60b600565">end</a> ()</td></tr>
<tr class="memdesc:a07bc452bc6022b65a0399de60b600565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator at the end of the container.  <a href="#a07bc452bc6022b65a0399de60b600565">More...</a><br/></td></tr>
<tr class="separator:a07bc452bc6022b65a0399de60b600565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab315a8270e95e35f27ff99d3bbc67bba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a50774ce617a742e76f3fb8cc0a7a9445">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#ab315a8270e95e35f27ff99d3bbc67bba">end</a> () const </td></tr>
<tr class="memdesc:ab315a8270e95e35f27ff99d3bbc67bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator at the end of the container.  <a href="#ab315a8270e95e35f27ff99d3bbc67bba">More...</a><br/></td></tr>
<tr class="separator:ab315a8270e95e35f27ff99d3bbc67bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57a44da3d8b2459dbd209d5d8b7a3c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad57a44da3d8b2459dbd209d5d8b7a3c9"></a>
<a class="el" href="classlgraph_1_1utils_1_1svector.html">svector</a>&lt; T, Alloc &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#ad57a44da3d8b2459dbd209d5d8b7a3c9">operator=</a> (const <a class="el" href="classlgraph_1_1utils_1_1svector.html">svector</a>&lt; T, Alloc &gt; &amp;s)</td></tr>
<tr class="memdesc:ad57a44da3d8b2459dbd209d5d8b7a3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr class="separator:ad57a44da3d8b2459dbd209d5d8b7a3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6943d4e89de5500202b9b01433b0f466"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a6943d4e89de5500202b9b01433b0f466">operator[]</a> (size_t i)</td></tr>
<tr class="memdesc:a6943d4e89de5500202b9b01433b0f466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the i-th element.  <a href="#a6943d4e89de5500202b9b01433b0f466">More...</a><br/></td></tr>
<tr class="separator:a6943d4e89de5500202b9b01433b0f466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88de6e0d075bc9a0dc3b1fed31207a43"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a88de6e0d075bc9a0dc3b1fed31207a43">operator[]</a> (size_t i) const </td></tr>
<tr class="memdesc:a88de6e0d075bc9a0dc3b1fed31207a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the i-th element.  <a href="#a88de6e0d075bc9a0dc3b1fed31207a43">More...</a><br/></td></tr>
<tr class="separator:a88de6e0d075bc9a0dc3b1fed31207a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ffd05a33eeae26ddb0909d8f64ad28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a14ffd05a33eeae26ddb0909d8f64ad28">add</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a14ffd05a33eeae26ddb0909d8f64ad28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to this container.  <a href="#a14ffd05a33eeae26ddb0909d8f64ad28">More...</a><br/></td></tr>
<tr class="separator:a14ffd05a33eeae26ddb0909d8f64ad28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d377cbaa26f09a862334363e2d889cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a9d377cbaa26f09a862334363e2d889cc">remove</a> (size_t i)</td></tr>
<tr class="memdesc:a9d377cbaa26f09a862334363e2d889cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element in the i-th position of this container.  <a href="#a9d377cbaa26f09a862334363e2d889cc">More...</a><br/></td></tr>
<tr class="separator:a9d377cbaa26f09a862334363e2d889cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df0b9cabdb2e9f572f664d85ba42efb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a1df0b9cabdb2e9f572f664d85ba42efb">remove</a> (size_t b, size_t e)</td></tr>
<tr class="memdesc:a1df0b9cabdb2e9f572f664d85ba42efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [b,e) of this container.  <a href="#a1df0b9cabdb2e9f572f664d85ba42efb">More...</a><br/></td></tr>
<tr class="separator:a1df0b9cabdb2e9f572f664d85ba42efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2199e164429f7469decfa9d8f033069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#ac2199e164429f7469decfa9d8f033069">sort</a> ()</td></tr>
<tr class="memdesc:ac2199e164429f7469decfa9d8f033069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of this vector.  <a href="#ac2199e164429f7469decfa9d8f033069">More...</a><br/></td></tr>
<tr class="separator:ac2199e164429f7469decfa9d8f033069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c67e3086677ea7f0c8526e3d12230aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a2c67e3086677ea7f0c8526e3d12230aa">find_remove</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a2c67e3086677ea7f0c8526e3d12230aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and remove an element from the container.  <a href="#a2c67e3086677ea7f0c8526e3d12230aa">More...</a><br/></td></tr>
<tr class="separator:a2c67e3086677ea7f0c8526e3d12230aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff2525161af10a94a64a0be8204556"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a59ff2525161af10a94a64a0be8204556">remove_several</a> (const std::set&lt; size_t &gt; &amp;poss)</td></tr>
<tr class="memdesc:a59ff2525161af10a94a64a0be8204556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the contents of several positions from the container.  <a href="#a59ff2525161af10a94a64a0be8204556">More...</a><br/></td></tr>
<tr class="separator:a59ff2525161af10a94a64a0be8204556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3c8a4fcd5234fbe2e05bb36d406b01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a2b3c8a4fcd5234fbe2e05bb36d406b01">remove_several_s</a> (const std::vector&lt; size_t &gt; &amp;poss)</td></tr>
<tr class="memdesc:a2b3c8a4fcd5234fbe2e05bb36d406b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the contents of several positions from the container.  <a href="#a2b3c8a4fcd5234fbe2e05bb36d406b01">More...</a><br/></td></tr>
<tr class="separator:a2b3c8a4fcd5234fbe2e05bb36d406b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5c1579ffdd022698756ba4c142dd86"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#afa5c1579ffdd022698756ba4c142dd86">size</a> () const </td></tr>
<tr class="memdesc:afa5c1579ffdd022698756ba4c142dd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in this vector.  <a href="#afa5c1579ffdd022698756ba4c142dd86">More...</a><br/></td></tr>
<tr class="separator:afa5c1579ffdd022698756ba4c142dd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17c14abafd02d01a0e1f8230ed23680"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#ab17c14abafd02d01a0e1f8230ed23680">contains</a> (const T &amp;v) const </td></tr>
<tr class="memdesc:ab17c14abafd02d01a0e1f8230ed23680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for an element equal to <em>v</em> in the container.  <a href="#ab17c14abafd02d01a0e1f8230ed23680">More...</a><br/></td></tr>
<tr class="separator:ab17c14abafd02d01a0e1f8230ed23680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71629dfb853c4e85a0a7f4b20f821d9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#ac71629dfb853c4e85a0a7f4b20f821d9">position</a> (const T &amp;v) const </td></tr>
<tr class="memdesc:ac71629dfb853c4e85a0a7f4b20f821d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for an element <em>v</em> in the vector and stores its position in <em>pos</em>.  <a href="#ac71629dfb853c4e85a0a7f4b20f821d9">More...</a><br/></td></tr>
<tr class="separator:ac71629dfb853c4e85a0a7f4b20f821d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150e04d045dc41f0c40398718f06106c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a150e04d045dc41f0c40398718f06106c">as_vector</a> (std::vector&lt; T, Alloc &gt; &amp;v) const </td></tr>
<tr class="memdesc:a150e04d045dc41f0c40398718f06106c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this shortened container into a regular C++'s vector.  <a href="#a150e04d045dc41f0c40398718f06106c">More...</a><br/></td></tr>
<tr class="separator:a150e04d045dc41f0c40398718f06106c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afd0bed68cf8eb4c07c8553c555fb2f3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#afd0bed68cf8eb4c07c8553c555fb2f3b">only_remove</a> (size_t i)</td></tr>
<tr class="memdesc:afd0bed68cf8eb4c07c8553c555fb2f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element in the i-th position of this container.  <a href="#afd0bed68cf8eb4c07c8553c555fb2f3b">More...</a><br/></td></tr>
<tr class="separator:afd0bed68cf8eb4c07c8553c555fb2f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d5e3d01e8cf40b13494d699a7f2eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#af9d5e3d01e8cf40b13494d699a7f2eef">shrink_if</a> ()</td></tr>
<tr class="memdesc:af9d5e3d01e8cf40b13494d699a7f2eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the underlying container.  <a href="#af9d5e3d01e8cf40b13494d699a7f2eef">More...</a><br/></td></tr>
<tr class="separator:af9d5e3d01e8cf40b13494d699a7f2eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7ef963c079c7dc8a6a559ceef81a241f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a></td></tr>
<tr class="memdesc:a7ef963c079c7dc8a6a559ceef81a241f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the next position available in the container.  <a href="#a7ef963c079c7dc8a6a559ceef81a241f">More...</a><br/></td></tr>
<tr class="separator:a7ef963c079c7dc8a6a559ceef81a241f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72e9ffeb58f88d3cb01671e3e672a45"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a></td></tr>
<tr class="memdesc:aa72e9ffeb58f88d3cb01671e3e672a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container used to allocate the elements.  <a href="#aa72e9ffeb58f88d3cb01671e3e672a45">More...</a><br/></td></tr>
<tr class="separator:aa72e9ffeb58f88d3cb01671e3e672a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0917cbb972bd75239a20e86164b5f7b6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlgraph_1_1utils_1_1svector.html#a0917cbb972bd75239a20e86164b5f7b6">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classlgraph_1_1utils_1_1svector.html">svector</a>&lt; T, Alloc &gt; &amp;v)</td></tr>
<tr class="memdesc:a0917cbb972bd75239a20e86164b5f7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs in an ostream object the contents of this container.  <a href="#a0917cbb972bd75239a20e86164b5f7b6">More...</a><br/></td></tr>
<tr class="separator:a0917cbb972bd75239a20e86164b5f7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt;<br/>
class lgraph::utils::svector&lt; T, Alloc &gt;</h3>

<p>Shortened vector. </p>
<p>This class implements a container that is, basically, a little shortcut in vectors for the ease of inserting/deleting elements without having to use iterators. It also avoids all the work that erasing an element from a STL's vector requires (moving all the memory in the positions after the removed element to the end).</p>
<p>A pointer determines the position next to the last element of the container. Any element added to the container is placed where <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> points at and then <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> is incremented. Any element removed is moved at the position before <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> and then <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> is decremented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of the elements stored. Must allow the use of '=' and '&lt;' operators.</td></tr>
    <tr><td class="paramname">Alloc</td><td>The allocator for the elements of type <em>T</em>. See the documentation for C++'s vectors for more details (<a href="http://en.cppreference.com/w/cpp/container/vector">http://en.cppreference.com/w/cpp/container/vector</a>). </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a14ffd05a33eeae26ddb0909d8f64ad28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an element to this container. </p>
<p>If <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> is equal to <a class="el" href="classlgraph_1_1utils_1_1svector.html#afa5c1579ffdd022698756ba4c142dd86" title="Returns the number of elements in this vector. ">size()</a> then the method push_back() is called. Otherwise, element <em>v</em> is copied to the position pointed by <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>. In both cases <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> is incremented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Value to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a150e04d045dc41f0c40398718f06106c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::as_vector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this shortened container into a regular C++'s vector. </p>
<p>Makes a vector&lt;T&gt; with all the elements in this shortened vector in the positions [0,..,<a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>). </p>

</div>
</div>
<a class="anchor" id="aeb8b316c538de8368b1efdbf7764ac91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlgraph_1_1utils_1_1svector.html">svector</a>&lt; T, Alloc &gt;::<a class="el" href="classlgraph_1_1utils_1_1svector.html#a518288794e754e27d2e2274ced4485a6">iterator</a> <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator at the beginning of the container. </p>
<p>This is not actually an iterator, but a pointer to the elements of the vector <a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the first element of <a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7345683988f337e5015850357ae08714"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlgraph_1_1utils_1_1svector.html">svector</a>&lt; T, Alloc &gt;::<a class="el" href="classlgraph_1_1utils_1_1svector.html#a50774ce617a742e76f3fb8cc0a7a9445">const_iterator</a> <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator at the beginning of the container. </p>
<p>This is not actually an iterator, but a pointer to the elements of the vector <a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a constant pointer to the first element of <a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab17c14abafd02d01a0e1f8230ed23680"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for an element equal to <em>v</em> in the container. </p>
<p>Performs a linear search on the contents of the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>THe element to be searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if there is an element equal to <em>v</em> in the container. </dd></dl>

</div>
</div>
<a class="anchor" id="a07bc452bc6022b65a0399de60b600565"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlgraph_1_1utils_1_1svector.html">svector</a>&lt; T, Alloc &gt;::<a class="el" href="classlgraph_1_1utils_1_1svector.html#a518288794e754e27d2e2274ced4485a6">iterator</a> <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator at the end of the container. </p>
<p>This is not actually an iterator, but a pointer to the elements of the vector <a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the last valid element of <a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab315a8270e95e35f27ff99d3bbc67bba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlgraph_1_1utils_1_1svector.html">svector</a>&lt; T, Alloc &gt;::<a class="el" href="classlgraph_1_1utils_1_1svector.html#a50774ce617a742e76f3fb8cc0a7a9445">const_iterator</a> <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator at the end of the container. </p>
<p>This is not actually an iterator, but a pointer to the elements of the vector <a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a constant pointer to the last valid element of <a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c67e3086677ea7f0c8526e3d12230aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::find_remove </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find and remove an element from the container. </p>
<p>Function that serves as a macro of finding the position of an element in the container and deleting the element in that position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The element to search and delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The first occurrence of element <em>v</em> is removed from the container if it exists.</dd></dl>
<p>The destructor of the element is not called. Therefore, the memory will have to be explicitly freed by the caller, unless the allocator already implements their destruction. </p>

</div>
</div>
<a class="anchor" id="afd0bed68cf8eb4c07c8553c555fb2f3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::only_remove </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element in the i-th position of this container. </p>
<p>Swaps the element in the <em>i-th</em> position with the element in the previous position pointed by <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>. Then decrements the value of <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>i</em> &lt; <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destructor of the element is not called. Therefore, the memory will have to be explicitly freed by the caller, unless the allocator already implements their destruction. </dd></dl>

</div>
</div>
<a class="anchor" id="a6943d4e89de5500202b9b01433b0f466"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the i-th element. </p>
<dl class="section pre"><dt>Precondition</dt><dd><em>i</em> &lt; <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a88de6e0d075bc9a0dc3b1fed31207a43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the i-th element. </p>
<dl class="section pre"><dt>Precondition</dt><dd><em>i</em> &lt; <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac71629dfb853c4e85a0a7f4b20f821d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::position </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for an element <em>v</em> in the vector and stores its position in <em>pos</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The element to be searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value smaller than <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> if v is in the container. Returns a value equal to <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> if otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d377cbaa26f09a862334363e2d889cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the element in the i-th position of this container. </p>
<p>Swaps the element in the <em>i-th</em> position with the element in the previous position pointed by <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>. Then decrements the value of <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the element to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>i</em> &lt; <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destructor of the element is not called. Therefore, the memory will have to be explicitly freed by the caller, unless the allocator already implements their destruction.</dd></dl>
<p>When <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> has reached half the total size of the container <a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a> the container is resized to a size equal to <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>. </p>

</div>
</div>
<a class="anchor" id="a1df0b9cabdb2e9f572f664d85ba42efb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the elements in the range [b,e) of this container. </p>
<p>It copies the elements in [<em>e</em>,<a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>) to the (<a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> - <em>e</em>) positions starting at <em>b</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The index of the first element to be removed. </td></tr>
    <tr><td class="paramname">e</td><td>The index of the last element to be removed plus 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>b</em> &lt; <em>e</em> &lt;= <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The destructor of the elements in the range [b,e) is not called. Therefore, the memory will have to be explicitly freed by the caller, unless the allocator already implements their destruction.</dd></dl>
<p>If <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> has reached half the total size of the container <a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a> the container is resized to a size equal to <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>. </p>

</div>
</div>
<a class="anchor" id="a59ff2525161af10a94a64a0be8204556"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::remove_several </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>poss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the contents of several positions from the container. </p>
<p>Consider the contents of the container at the state prior the deletion. After the deletion the contents of the container are all the elements except those pointed by the positions in <em>poss</em> at the previous state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poss</td><td>Set of positions to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All elements in <em>poss</em> must be strictly smaller than the size of the container (see <a class="el" href="classlgraph_1_1utils_1_1svector.html#afa5c1579ffdd022698756ba4c142dd86">size()</a>) at the state prior the deletion. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The contents of the container need not preserve the original order. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b3c8a4fcd5234fbe2e05bb36d406b01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::remove_several_s </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>poss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the contents of several positions from the container. </p>
<p>Consider the contents of the container at the state prior the deletion. After the deletion the contents of the container are all the elements except those pointed by the positions in <em>poss</em> at the previous state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poss</td><td>List of positions to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All elements in <em>poss</em> must be strictly smaller than the size of the container (see <a class="el" href="classlgraph_1_1utils_1_1svector.html#afa5c1579ffdd022698756ba4c142dd86">size()</a>) at the state prior the deletion. The elements in <em>poss</em> must be increasingly sorted. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The contents of the container do not necessarily preserve the original order. </dd></dl>

</div>
</div>
<a class="anchor" id="af9d5e3d01e8cf40b13494d699a7f2eef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::shrink_if </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shrinks the underlying container. </p>
<p>In case the effective amount of elements in the container (value of <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>) is smaller than the vector's size (size of <a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a>) then <a class="el" href="classlgraph_1_1utils_1_1svector.html#aa72e9ffeb58f88d3cb01671e3e672a45">elems</a> is resized to fit only <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> elements. </p>

</div>
</div>
<a class="anchor" id="afa5c1579ffdd022698756ba4c142dd86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac2199e164429f7469decfa9d8f033069"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements of this vector. </p>
<p>Sorts the elements in positions [0,..,<a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>) </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a0917cbb972bd75239a20e86164b5f7b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlgraph_1_1utils_1_1svector.html">svector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs in an ostream object the contents of this container. </p>
<p>The contents passed to the ostream object are all those elements whose index is strictly below <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa72e9ffeb58f88d3cb01671e3e672a45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T,Alloc&gt; <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::elems</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container used to allocate the elements. </p>
<p>The valid elements in this container are found within range of indices [0,<a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>).</p>
<p>The new element added to this container will be placed in the position elems[<a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>]. </p>

</div>
</div>
<a class="anchor" id="a7ef963c079c7dc8a6a559ceef81a241f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classlgraph_1_1utils_1_1svector.html">lgraph::utils::svector</a>&lt; T, Alloc &gt;::idx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the next position available in the container. </p>
<p>For example: </p>
<pre class="fragment">*                   \/
* contents: 0 1 2 3 __
* </pre><p> <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a> points at the position after element 3. The next new element added will be stored in the position pointed by <a class="el" href="classlgraph_1_1utils_1_1svector.html#a7ef963c079c7dc8a6a559ceef81a241f">idx</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lgraph/utils/<a class="el" href="svector_8hpp_source.html">svector.hpp</a></li>
<li>lgraph/utils/svector.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
